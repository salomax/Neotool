---
title: Domain to Entity Conversion Pattern
type: pattern
category: backend
status: current
version: 1.0.0
tags: [domain, entity, conversion, mapping, kotlin, jpa]
ai_optimized: true
search_keywords: [domain, entity, conversion, mapping, toEntity, toDomain, nullable, UUID]
related:
  - 05-standards/database-standards/schema-standards.md
  - 05-standards/coding-standards/kotlin-standards.md
---

# Domain to Entity Conversion Pattern

> **Purpose**: Rules and patterns for converting between domain objects and JPA entities, ensuring type safety and preventing common conversion errors.

## Overview

This pattern defines how to safely convert between domain objects (in the `domain` package) and JPA entities (in the `model` package). The key challenge is handling nullable vs non-nullable ID types correctly.

## Core Principle

**Domain objects use nullable IDs** (`UUID?` or `Int?`) to represent new entities that haven't been persisted yet. **JPA entities use non-nullable IDs** (`UUID` or `Int`) because they represent persisted database records.

## Rule: Nullable ID Handling in `toEntity()`

### Rule: UUID-based Entities

**Rule**: When converting a domain object with a nullable `UUID?` id to an entity with a non-nullable `UUID` id, use the Elvis operator to generate a new UUID when the id is null.

**Rationale**: 
- Domain objects allow `null` IDs for new entities
- JPA entities require non-null IDs (with default generation)
- The entity constructor typically has `UUID.randomUUID()` as default, but we should be explicit

**Example**:
```kotlin
// ✅ Correct
data class AbacPolicy(
    val id: UUID? = null,
    val name: String,
    // ... other fields
) {
    fun toEntity(): AbacPolicyEntity {
        return AbacPolicyEntity(
            id = this.id ?: UUID.randomUUID(),  // Generate UUID if null
            name = this.name,
            // ... other fields
        )
    }
}

// ❌ Incorrect - Type mismatch error
fun toEntity(): AbacPolicyEntity {
    return AbacPolicyEntity(
        id = this.id,  // Error: UUID? cannot be assigned to UUID
        // ...
    )
}
```

### Rule: Int-based Entities (Auto-generated)

**Rule**: When converting a domain object with a nullable `Int?` id to an entity with a nullable `Int?` id (using `@GeneratedValue`), pass the id directly.

**Rationale**: 
- Both domain and entity use nullable `Int?` for auto-generated IDs
- The database will generate the ID on insert
- No conversion needed

**Example**:
```kotlin
// ✅ Correct
data class Role(
    val id: Int? = null,
    val name: String,
    // ... other fields
) {
    fun toEntity(): RoleEntity {
        return RoleEntity(
            id = this.id,  // Both are Int?, no conversion needed
            name = this.name,
            // ... other fields
        )
    }
}
```

### Rule: Entity to Domain Conversion

**Rule**: When converting from entity to domain, pass the id directly since entities always have non-null IDs.

**Rationale**: 
- Entities represent persisted records with non-null IDs
- Domain objects can accept non-null IDs
- No conversion needed

**Example**:
```kotlin
// ✅ Correct
open class AbacPolicyEntity(
    override val id: UUID = UUID.randomUUID(),
    // ... other fields
) {
    fun toDomain(): AbacPolicy {
        return AbacPolicy(
            id = this.id,  // UUID can be assigned to UUID?
            // ... other fields
        )
    }
}
```

## Common Patterns

### Pattern: UUID-based Entity (Client-generated)

```kotlin
// Domain Object
data class Group(
    val id: UUID? = null,  // Nullable for new entities
    val name: String,
    // ...
) {
    fun toEntity(): GroupEntity {
        return GroupEntity(
            id = this.id ?: UUID.randomUUID(),  // Generate if null
            name = this.name,
            // ...
        )
    }
}

// Entity
open class GroupEntity(
    @Id
    @Column(columnDefinition = "uuid")
    override val id: UUID = UUID.randomUUID(),  // Non-nullable with default
    // ...
) {
    fun toDomain(): Group {
        return Group(
            id = this.id,  // UUID → UUID? is safe
            name = this.name,
            // ...
        )
    }
}
```

### Pattern: Int-based Entity (Database-generated)

```kotlin
// Domain Object
data class Role(
    val id: Int? = null,  // Nullable for new entities
    val name: String,
    // ...
) {
    fun toEntity(): RoleEntity {
        return RoleEntity(
            id = this.id,  // Both nullable, no conversion needed
            name = this.name,
            // ...
        )
    }
}

// Entity
open class RoleEntity(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    override val id: Int? = null,  // Nullable, generated by DB
    // ...
) {
    fun toDomain(): Role {
        return Role(
            id = this.id,  // Both nullable, direct assignment
            name = this.name,
            // ...
        )
    }
}
```

## Checklist for Domain-Entity Conversion

When creating or updating domain-to-entity conversions, verify:

- [ ] **Domain object ID type**: Is it `UUID?` or `Int?`?
- [ ] **Entity ID type**: Is it `UUID` (non-nullable) or `Int?` (nullable)?
- [ ] **toEntity() method**: 
  - If domain has `UUID?` and entity has `UUID`: Use `id ?: UUID.randomUUID()`
  - If both have `Int?`: Use `id` directly
- [ ] **toDomain() method**: 
  - If entity has `UUID` and domain has `UUID?`: Use `id` directly (safe conversion)
  - If both have `Int?`: Use `id` directly
- [ ] **Import statements**: Ensure `java.util.UUID` is imported when using UUID

## Anti-Patterns

### ❌ Anti-Pattern: Direct Assignment of Nullable to Non-Nullable

```kotlin
// ❌ This will cause a compilation error
fun toEntity(): GroupEntity {
    return GroupEntity(
        id = this.id,  // Error: UUID? cannot be assigned to UUID
        // ...
    )
}
```

### ❌ Anti-Pattern: Unnecessary Null Check

```kotlin
// ❌ Overly verbose - use Elvis operator instead
fun toEntity(): GroupEntity {
    return GroupEntity(
        id = if (this.id != null) this.id else UUID.randomUUID(),
        // ...
    )
}
```

### ❌ Anti-Pattern: Wrong Default Value

```kotlin
// ❌ Don't use null as default for non-nullable entity ID
open class GroupEntity(
    override val id: UUID = null,  // Error: null cannot be assigned to UUID
    // ...
)
```

## Testing Considerations

When testing domain-to-entity conversion:

1. **Test with null ID**: Verify that a new UUID is generated
2. **Test with existing ID**: Verify that the existing ID is preserved
3. **Test entity-to-domain**: Verify that non-null entity IDs convert correctly

**Example Test**:
```kotlin
@Test
fun `toEntity should generate UUID when id is null`() {
    val domain = Group(id = null, name = "Test Group")
    val entity = domain.toEntity()
    
    assertThat(entity.id).isNotNull()
    assertThat(entity.name).isEqualTo("Test Group")
}

@Test
fun `toEntity should preserve existing UUID`() {
    val existingId = UUID.randomUUID()
    val domain = Group(id = existingId, name = "Test Group")
    val entity = domain.toEntity()
    
    assertThat(entity.id).isEqualTo(existingId)
}
```

## Related Documentation

- [Database Standards](../05-standards/database-standards/schema-standards.md) - Entity structure and ID generation
- [Kotlin Coding Standards](../05-standards/coding-standards/kotlin-standards.md) - General Kotlin conventions
- [Clean Architecture Principles](../../00-overview/principles.md) - Domain/Entity separation rationale

