package io.github.salomax.neotool.{module}.repo

import io.github.salomax.neotool.{module}.entity.{EntityName}Entity
import io.micronaut.transaction.annotation.ReadOnly
import jakarta.inject.Singleton
import jakarta.persistence.EntityManager
import jakarta.persistence.TypedQuery
import jakarta.persistence.criteria.CriteriaBuilder
import jakarta.persistence.criteria.CriteriaQuery
import jakarta.persistence.criteria.Predicate
import jakarta.persistence.criteria.Root
import java.util.UUID

/**
 * Custom repository implementation for {@link {EntityName}RepositoryCustom}.
 * 
 * This class provides custom implementations for complex queries that cannot be
 * auto-generated by Micronaut Data. Uses JPA Criteria API for building dynamic queries.
 * 
 * Replace:
 * - {module} with your module name (app, security, assistant, etc.)
 * - {EntityName} with your entity name (e.g., Product, Customer)
 * 
 * IMPORTANT:
 * - Must be annotated with @Singleton
 * - Must implement {EntityName}RepositoryCustom interface
 * - Use EntityManager and Criteria API for query building
 * - Add @ReadOnly annotation to all read-only query methods (performance optimization)
 * - Extract common predicate logic into private helper methods
 * 
 * See repository-pattern.md for complete pattern documentation.
 */
@Singleton
class {EntityName}RepositoryImpl(
    private val entityManager: EntityManager,
) : {EntityName}RepositoryCustom {

    /**
     * Example: Build a search filter predicate.
     * Extract common logic into private methods for reuse.
     */
    private fun buildSearchFilterPredicate(
        root: Root<{EntityName}Entity>,
        criteriaBuilder: CriteriaBuilder,
        query: String?,
    ): Predicate? {
        // Implement your filter logic here
        // Return null if no filter should be applied
        return null
    }

    /**
     * Example: Custom search implementation.
     * Implement methods from {EntityName}RepositoryCustom interface.
     * 
     * IMPORTANT: Add @ReadOnly annotation to all read-only query methods.
     */
    @ReadOnly
    override fun searchByNameOrEmail(
        query: String?,
        first: Int,
        after: UUID?,
    ): List<{EntityName}Entity> {
        val criteriaBuilder = entityManager.criteriaBuilder
        val criteriaQuery = criteriaBuilder.createQuery({EntityName}Entity::class.java)
        val root = criteriaQuery.from({EntityName}Entity::class.java)

        // Build WHERE clause predicates
        val predicates = mutableListOf<Predicate>()

        // Add custom filters
        buildSearchFilterPredicate(root, criteriaBuilder, query)?.let {
            predicates.add(it)
        }

        // Add cursor pagination if needed
        if (after != null) {
            predicates.add(criteriaBuilder.greaterThan(root.get<UUID>("id"), after))
        }

        // Apply WHERE clause
        if (predicates.isNotEmpty()) {
            criteriaQuery.where(*predicates.toTypedArray())
        }

        // Build ordering
        criteriaQuery.orderBy(
            criteriaBuilder.asc(root.get<UUID>("id"))
        )

        // Execute query with limit
        val typedQuery: TypedQuery<{EntityName}Entity> = entityManager.createQuery(criteriaQuery)
        typedQuery.maxResults = first

        return typedQuery.resultList
    }

    /**
     * Example: Custom count implementation.
     * Implement methods from {EntityName}RepositoryCustom interface.
     * 
     * IMPORTANT: Add @ReadOnly annotation to all read-only query methods.
     */
    @ReadOnly
    override fun countByNameOrEmail(query: String?): Long {
        val criteriaBuilder = entityManager.criteriaBuilder
        val criteriaQuery = criteriaBuilder.createQuery(Long::class.java)
        val root = criteriaQuery.from({EntityName}Entity::class.java)

        criteriaQuery.select(criteriaBuilder.count(root))

        // Add custom filters
        buildSearchFilterPredicate(root, criteriaBuilder, query)?.let {
            criteriaQuery.where(it)
        }

        return entityManager.createQuery(criteriaQuery).singleResult
    }
}

