# User type for authentication and authorization
type User @key(fields: "id") {
  id: ID!
  email: String!
  displayName: String
  avatarUrl: String
  enabled: Boolean!
  createdAt: String!
  updatedAt: String!
  roles: [Role!]!
  groups: [Group!]!
  permissions: [Permission!]!
}

# Query type for security operations
extend type Query {
  # Authentication queries
  currentUser: User

  # Authorization queries
  checkPermission(userId: ID!, permission: String!, resourceId: ID): AuthorizationResult!

  # Authorization management queries
  user(id: ID!): User
  users(first: Int, after: String, query: String, orderBy: [UserOrderByInput!]): UserConnection!
  group(id: ID!): Group
  groups(first: Int, after: String, query: String, orderBy: [GroupOrderByInput!]): GroupConnection!
  role(id: ID!): Role
  roles(first: Int, after: String, query: String, orderBy: [RoleOrderByInput!]): RoleConnection!
  permissions(first: Int, after: String, query: String): PermissionConnection!
}

# Mutation type for security operations
extend type Mutation {
  # Authentication mutations
  signIn(input: SignInInput!): SignInPayload!
  signInWithOAuth(input: SignInWithOAuthInput!): SignInPayload!
  signUp(input: SignUpInput!): SignUpPayload!
  refreshAccessToken(input: RefreshAccessTokenInput!): SignInPayload!
  requestPasswordReset(input: RequestPasswordResetInput!): RequestPasswordResetPayload!
  resetPassword(input: ResetPasswordInput!): ResetPasswordPayload!

  # Authorization management mutations
  enableUser(userId: ID!): User!
  disableUser(userId: ID!): User!
  updateUser(userId: ID!, input: UpdateUserInput!): User!
  createGroup(input: CreateGroupInput!): Group!
  updateGroup(groupId: ID!, input: UpdateGroupInput!): Group!
  deleteGroup(groupId: ID!): Boolean!
  createRole(input: CreateRoleInput!): Role!
  updateRole(roleId: ID!, input: UpdateRoleInput!): Role!
  deleteRole(roleId: ID!): Boolean!
  assignPermissionToRole(roleId: ID!, permissionId: ID!): Role!
  removePermissionFromRole(roleId: ID!, permissionId: ID!): Role!
  assignGroupToUser(userId: ID!, groupId: ID!): User!
  removeGroupFromUser(userId: ID!, groupId: ID!): User!
  assignRoleToGroup(groupId: ID!, roleId: ID!): Group!
  removeRoleFromGroup(groupId: ID!, roleId: ID!): Group!
}

# Authentication input types
input SignInInput {
  email: String!
  password: String!
  rememberMe: Boolean
}

input SignInWithOAuthInput {
  provider: String!  # "google", "microsoft", etc.
  idToken: String!   # OAuth ID token (JWT) from the provider
  rememberMe: Boolean
}

type SignInPayload {
  token: String!
  refreshToken: String
  user: User!
}

# Sign up input types
input SignUpInput {
  name: String!
  email: String!
  password: String!
}

type SignUpPayload {
  token: String!
  refreshToken: String
  user: User!
}

# Password reset input types
input RequestPasswordResetInput {
  email: String!
  locale: String
}

type RequestPasswordResetPayload {
  success: Boolean!
  message: String!
}

input RefreshAccessTokenInput {
  refreshToken: String!
}

input ResetPasswordInput {
  token: String!
  newPassword: String!
}

type ResetPasswordPayload {
  success: Boolean!
  message: String!
}

# Authorization types
type AuthorizationResult {
  allowed: Boolean!
  reason: String!
}

type Permission @key(fields: "id") {
  id: ID!
  name: String!
  roles: [Role!]!
}

type Role @key(fields: "id") {
  id: ID!
  name: String!
  createdAt: String!
  updatedAt: String!
  groups: [Group!]!
  permissions: [Permission!]!
}

type Group @key(fields: "id") {
  id: ID!
  name: String!
  description: String
  createdAt: String!
  updatedAt: String!
  roles: [Role!]!
  members: [User!]!
}

# Relay pagination types
type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type UserEdge {
  node: User!
  cursor: String!
}

type GroupEdge {
  node: Group!
  cursor: String!
}

type RoleEdge {
  node: Role!
  cursor: String!
}

type PermissionEdge {
  node: Permission!
  cursor: String!
}

type UserConnection {
  edges: [UserEdge!]!
  pageInfo: PageInfo!
  totalCount: Int
}

type GroupConnection {
  edges: [GroupEdge!]!
  pageInfo: PageInfo!
  totalCount: Int
}

type RoleConnection {
  edges: [RoleEdge!]!
  pageInfo: PageInfo!
  totalCount: Int
}

type PermissionConnection {
  edges: [PermissionEdge!]!
  pageInfo: PageInfo!
}

# Input types for authorization management
input CreateGroupInput {
  name: String!
  description: String
  userIds: [ID!]
}

input UpdateGroupInput {
  name: String!
  description: String
  userIds: [ID!]
}

input CreateRoleInput {
  name: String!
}

input UpdateRoleInput {
  name: String!
}

input UpdateUserInput {
  displayName: String
}

# Sorting enums and input types
enum OrderDirection {
  ASC
  DESC
}

enum UserOrderField {
  DISPLAY_NAME
  EMAIL
}

enum GroupOrderField {
  NAME
}

enum RoleOrderField {
  NAME
}

input UserOrderByInput {
  field: UserOrderField!
  direction: OrderDirection!
}

input GroupOrderByInput {
  field: GroupOrderField!
  direction: OrderDirection!
}

input RoleOrderByInput {
  field: RoleOrderField!
  direction: OrderDirection!
}

