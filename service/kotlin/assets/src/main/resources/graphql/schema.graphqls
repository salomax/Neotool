# ============================================================================
# Asset Management GraphQL Schema
#
# Handles asset upload lifecycle:
# 1. Client calls createAssetUpload mutation to get pre-signed upload URL
# 2. Client uploads file directly to S3/R2 using the pre-signed upload URL
# 3. Client calls confirmAssetUpload mutation to mark upload as complete
# 4. Asset is now READY and accessible via publicUrl
# ============================================================================

# ============================================================================
# Scalars
# ============================================================================

scalar Long

# ============================================================================
# Types
# ============================================================================

"""
Asset resource types - categorizes assets by their usage.
@deprecated Resource type is now informational/metadata only, not used in storage key generation
"""
enum AssetResourceType {
    """User profile image"""
    PROFILE_IMAGE

    """Institution/organization logo"""
    INSTITUTION_LOGO

    """Generic file attachment (documents, PDFs, etc.)"""
    ATTACHMENT
}

"""
Asset visibility level - determines access control and URL generation.
"""
enum AssetVisibility {
    """Public asset - accessible without owner check, uses stable CDN URLs"""
    PUBLIC

    """Private asset - requires ownership check, uses presigned download URLs"""
    PRIVATE
}

"""
Asset upload lifecycle status.
"""
enum AssetStatus {
    """Upload URL generated, waiting for client upload"""
    PENDING

    """File uploaded and confirmed, ready for use"""
    READY

    """Upload failed or expired"""
    FAILED

    """Asset deleted"""
    DELETED
}

"""
Asset metadata and access information.
"""
type Asset {
    """Unique identifier (UUID v7)"""
    id: ID!

    """User or system that owns this asset"""
    ownerId: String!

    """Logical grouping (e.g., user-profiles, group-assets)"""
    namespace: String!

    """Visibility level - determines access control and URL generation"""
    visibility: AssetVisibility!

    """
    Type of resource this asset represents.
    @deprecated Resource type is now informational/metadata only, not used in storage key generation
    """
    resourceType: AssetResourceType! @deprecated(reason: "Resource type is now informational only")

    """
    ID of the resource this asset is attached to.
    @deprecated Resource ID is now informational/metadata only, not used in storage key generation
    """
    resourceId: String! @deprecated(reason: "Resource ID is now informational only")

    """Unique key in S3/R2 storage"""
    storageKey: String!

    """Storage region"""
    storageRegion: String!

    """Storage bucket name"""
    storageBucket: String!

    """MIME type (e.g., image/jpeg, application/pdf)"""
    mimeType: String!

    """File size in bytes (null until upload confirmed)"""
    sizeBytes: Long

    """SHA-256 checksum for integrity verification"""
    checksum: String

    """Original filename from client upload"""
    originalFilename: String

    """
    Pre-signed upload URL (temporary, only available for PENDING assets).
    Client uploads file directly to this URL.
    """
    uploadUrl: String

    """When the upload URL expires"""
    uploadExpiresAt: DateTime

    """
    Public CDN URL for accessing the asset.
    Only available for READY PUBLIC assets. Returns null for PRIVATE assets (use downloadUrl instead).
    """
    publicUrl: String

    """
    Presigned download URL for PRIVATE assets.
    Returns null for PUBLIC assets (use publicUrl instead).
    @param ttlSeconds Time-to-live for the presigned URL (default: 3600 seconds / 1 hour)
    """
    downloadUrl(ttlSeconds: Int = 3600): String

    """Upload status"""
    status: AssetStatus!

    """Client-provided key to prevent duplicate uploads (optional)"""
    idempotencyKey: String

    """Timestamp when asset record was created"""
    createdAt: DateTime!

    """Timestamp when asset record was last updated"""
    updatedAt: DateTime!

    """Timestamp when asset was deleted (null if active)"""
    deletedAt: DateTime
}

# ============================================================================
# Input Types
# ============================================================================

"""
Input for creating a new asset upload.
"""
input CreateAssetUploadInput {
    """
    Logical namespace for the asset (e.g., "user-profiles", "group-assets").
    Determines validation rules (allowed MIME types, max file size), visibility, and storage key template.
    """
    namespace: String!

    """Original filename"""
    filename: String!

    """MIME type of the file"""
    mimeType: String!

    """File size in bytes"""
    sizeBytes: Long!

    """
    Optional idempotency key to prevent duplicate uploads.
    If provided, subsequent calls with the same key within 24 hours
    will return the existing asset instead of creating a new one.
    """
    idempotencyKey: String
}

"""
Input for confirming an asset upload.
"""
input ConfirmAssetUploadInput {
    """ID of the asset to confirm"""
    assetId: ID!

    """
    Optional SHA-256 checksum to verify file integrity.
    If provided, server will validate against actual file checksum.
    """
    checksum: String
}

# ============================================================================
# Queries
# ============================================================================

extend type Query {
    """
    Get asset by ID.
    Returns null if asset not found or user doesn't have access.
    """
    asset(id: ID!): Asset
}

# ============================================================================
# Mutations
# ============================================================================

extend type Mutation {
    """
    Step 1: Create asset upload and get pre-signed URL.

    This mutation:
    1. Validates MIME type and file size against namespace configuration
    2. Creates PENDING asset record in database
    3. Generates pre-signed S3/R2 upload URL (valid for 15 minutes)
    4. Returns asset with uploadUrl

    Client should then:
    - Upload file directly to S3/R2 using the uploadUrl (PUT request)
    - Call confirmAssetUpload mutation after upload completes

    Example usage:
    ```graphql
    mutation {
      createAssetUpload(input: {
        namespace: "user-profiles"
        resourceType: PROFILE_IMAGE
        resourceId: "user-123"
        filename: "avatar.jpg"
        mimeType: "image/jpeg"
        sizeBytes: 1048576
      }) {
        id
        uploadUrl
        uploadExpiresAt
        status
      }
    }
    ```
    """
    createAssetUpload(input: CreateAssetUploadInput!): Asset!

    """
    Step 2: Confirm asset upload after client completes file upload.

    This mutation:
    1. Verifies file exists in S3/R2 storage
    2. Optionally validates checksum if provided
    3. Updates asset status to READY
    4. Generates public CDN URL
    5. Returns updated asset with publicUrl

    Example usage:
    ```graphql
    mutation {
      confirmAssetUpload(input: {
        assetId: "01234567-89ab-cdef-0123-456789abcdef"
        checksum: "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855"
      }) {
        id
        status
        publicUrl
      }
    }
    ```
    """
    confirmAssetUpload(input: ConfirmAssetUploadInput!): Asset!

    """
    Delete an asset.

    This mutation:
    1. Deletes the file from S3/R2 storage
    2. Hard-deletes the asset record from the database

    Only the asset owner can delete the asset.
    """
    deleteAsset(assetId: ID!): Boolean!
}
